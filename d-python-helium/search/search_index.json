{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"d-python-helium \u00b6 Like d-python-files , but for serving static sites instead of files. Static files only. Port and bind address should both be configurable. Helium Application \u00b6 The helium appcliation is a twisted network application that serves different folders of static content on different ports. See Helium.md . Dockerfile and Base Image \u00b6 The core idea behind python helium is to be as lightweight as possible, so this uses jfloff/alpine-python:recent (see jflof/alpine-python ). See Docker.md Static Content Layout \u00b6 Python Helium expects static content to live in /www inside the container. The document below details how to bind-mount each subdomain's static content/one-pager into the container for the helium.py application. See Layout.md Note on Future Development \u00b6 At this point, this repo was abandoned in favor of d-nginx-subdomains , but it is a useful tool that we'll keep around for a future application.","title":"Home"},{"location":"#d-python-helium","text":"Like d-python-files , but for serving static sites instead of files. Static files only. Port and bind address should both be configurable.","title":"d-python-helium"},{"location":"#helium-application","text":"The helium appcliation is a twisted network application that serves different folders of static content on different ports. See Helium.md .","title":"Helium Application"},{"location":"#dockerfile-and-base-image","text":"The core idea behind python helium is to be as lightweight as possible, so this uses jfloff/alpine-python:recent (see jflof/alpine-python ). See Docker.md","title":"Dockerfile and Base Image"},{"location":"#static-content-layout","text":"Python Helium expects static content to live in /www inside the container. The document below details how to bind-mount each subdomain's static content/one-pager into the container for the helium.py application. See Layout.md","title":"Static Content Layout"},{"location":"#note-on-future-development","text":"At this point, this repo was abandoned in favor of d-nginx-subdomains , but it is a useful tool that we'll keep around for a future application.","title":"Note on Future Development"},{"location":"Docker/","text":"Dockerfile and Base Image \u00b6 The core idea behind python helium is to be as lightweight as possible, so this is based on the lightweight jfloff/alpine-python image. Docker and Docker Compose \u00b6 The Dockerfile extends jfloff/alpine-python:recent-slim and installs twisted into the container on first run. This can be used standalone by building using docker build . However, the preferred way to use this image is to use the docker-compose file: docker-compose build docker-compose up -d docker-compose down Network \u00b6 This requires the container to listen for requests on multiple ports. The container should be bound to the correct address. If Python Helium is listening for requests from an nginx container in the same pod, you can listen for any incoming request (no need to bind to a particular address). In this case the container will not have any external interface. If Python Helium is listening for requests over a VPN, the service should be bound to the VPN IP address of the machine. This will ensure that the server only responds to (encrypted) requests from machines on the VPN. Volumes and Bind Mounting \u00b6 The Dockerfile expects the application to be at: /app/helium.py so bind mount the helium.py application to /app/helium.py when you run this container.","title":"Docker"},{"location":"Docker/#dockerfile-and-base-image","text":"The core idea behind python helium is to be as lightweight as possible, so this is based on the lightweight jfloff/alpine-python image.","title":"Dockerfile and Base Image"},{"location":"Docker/#docker-and-docker-compose","text":"The Dockerfile extends jfloff/alpine-python:recent-slim and installs twisted into the container on first run. This can be used standalone by building using docker build . However, the preferred way to use this image is to use the docker-compose file: docker-compose build docker-compose up -d docker-compose down","title":"Docker and Docker Compose"},{"location":"Docker/#network","text":"This requires the container to listen for requests on multiple ports. The container should be bound to the correct address. If Python Helium is listening for requests from an nginx container in the same pod, you can listen for any incoming request (no need to bind to a particular address). In this case the container will not have any external interface. If Python Helium is listening for requests over a VPN, the service should be bound to the VPN IP address of the machine. This will ensure that the server only responds to (encrypted) requests from machines on the VPN.","title":"Network"},{"location":"Docker/#volumes-and-bind-mounting","text":"The Dockerfile expects the application to be at: /app/helium.py so bind mount the helium.py application to /app/helium.py when you run this container.","title":"Volumes and Bind Mounting"},{"location":"Helium/","text":"Helium Application \u00b6 The helium appcliation is a twisted network application that serves different folders of static content on different ports. A straightforward example of what we are doing is available in the python-multiport repository at static_content.py . The gist of the program is this: For each static site: Create a twisted.File resource that points to the static directory Create a twisted.Site factory that creates an http listener on a port Glue the http listener to a unique TCP port on the host machine Run the twisted.Site.listen() method to add the listener to the twisted application Run the twisted application It can be run like any python program, python helium.py","title":"Helium"},{"location":"Helium/#helium-application","text":"The helium appcliation is a twisted network application that serves different folders of static content on different ports. A straightforward example of what we are doing is available in the python-multiport repository at static_content.py . The gist of the program is this: For each static site: Create a twisted.File resource that points to the static directory Create a twisted.Site factory that creates an http listener on a port Glue the http listener to a unique TCP port on the host machine Run the twisted.Site.listen() method to add the listener to the twisted application Run the twisted application It can be run like any python program, python helium.py","title":"Helium Application"},{"location":"Layout/","text":"Static Content Layout: Inside Container \u00b6 Insie of the container, Python Helium expects static content to be present in /www . Each site should follow the schema of: /www/<subdomain-url>/htdocs where htdocs is a cloned copy of the gh-pages branch of the repository for that subdomain's one pager. For example, the bots subdomain bots.charlesreid1.com has the layout: /www bots.charlesreid1.com/ htdocs/ index.html css/ js/ ... pages.charlesreid1.com hooks.charlesreid1.com api.charlesreid1.com and htdocs is the repo at https://git.charlesreid1.com/charlesreid1/bots.charlesreid1.com .","title":"Layout"},{"location":"Layout/#static-content-layout-inside-container","text":"Insie of the container, Python Helium expects static content to be present in /www . Each site should follow the schema of: /www/<subdomain-url>/htdocs where htdocs is a cloned copy of the gh-pages branch of the repository for that subdomain's one pager. For example, the bots subdomain bots.charlesreid1.com has the layout: /www bots.charlesreid1.com/ htdocs/ index.html css/ js/ ... pages.charlesreid1.com hooks.charlesreid1.com api.charlesreid1.com and htdocs is the repo at https://git.charlesreid1.com/charlesreid1/bots.charlesreid1.com .","title":"Static Content Layout: Inside Container"}]}