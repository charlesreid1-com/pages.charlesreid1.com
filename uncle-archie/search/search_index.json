{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"uncle-archie \u00b6 Uncle Archie is a home-brewed continuous integration server. It handles pull request checks (build-test) and push-to-deploy functionality (build-test-deploy). It is written in Python and uses PyGithub. Uncle Archie is intended to run behind an nginx reverse proxy so that SSL can be used. This requires that the server running Uncle Archie be accessible via a domain name, and not just a bare IP address. Documentation: https://pages.charlesreid1.com/uncle-archie Source code: https://git.charlesreid1.com/bots/uncle-archie Source code mirror: https://github.com/charlesreid1/uncle-archie Table of Contents \u00b6 Uncle Archie: How It Works Quick Start DevOps: Flask Webhook Server Nginx Web Server Uncle Archie Startup Service Payloads and Hooks and Things: How Payloads Are Processed Creating Payload Hooks Acknowledgements","title":"Index"},{"location":"#uncle-archie","text":"Uncle Archie is a home-brewed continuous integration server. It handles pull request checks (build-test) and push-to-deploy functionality (build-test-deploy). It is written in Python and uses PyGithub. Uncle Archie is intended to run behind an nginx reverse proxy so that SSL can be used. This requires that the server running Uncle Archie be accessible via a domain name, and not just a bare IP address. Documentation: https://pages.charlesreid1.com/uncle-archie Source code: https://git.charlesreid1.com/bots/uncle-archie Source code mirror: https://github.com/charlesreid1/uncle-archie","title":"uncle-archie"},{"location":"#table-of-contents","text":"Uncle Archie: How It Works Quick Start DevOps: Flask Webhook Server Nginx Web Server Uncle Archie Startup Service Payloads and Hooks and Things: How Payloads Are Processed Creating Payload Hooks Acknowledgements","title":"Table of Contents"},{"location":"ack/","text":"Acknowledgements \u00b6 Uncle Archie the home-brewed CI server is implemented in Python using Flask to provide a front-end web server and PyGithub and requests to interact with the Github API. Uncle Archie is based largely on Captain Hook , which is itself inspired by and forked from carlos-jenkins/python-github-webhooks on Github.","title":"Acknowledgements"},{"location":"ack/#acknowledgements","text":"Uncle Archie the home-brewed CI server is implemented in Python using Flask to provide a front-end web server and PyGithub and requests to interact with the Github API. Uncle Archie is based largely on Captain Hook , which is itself inspired by and forked from carlos-jenkins/python-github-webhooks on Github.","title":"Acknowledgements"},{"location":"flask/","text":"Flask Webhook Server \u00b6 The front end component of Uncle Archie is the flask webhook server. This is a server with one endpoint. It receives webhooks and passes them on to Python hook functions on the back end. Port and Bind Address \u00b6 The Flask server listens on port 5005. Uncle Archie binds to 127.0.0.1:5005 on the host it runs on. (Note: this is important for the Nginx setup.) Routes \u00b6 Send all webhooks to Uncle Archie's /webhook endpoint. If your Uncle Archie server is running at archie.mydomain.com , then the URL for your webhook (the one you will install into Github repositories) will be https://archie.mydomain.com/webhook . (Also see the Nginx page.) Github webhooks are just JSON payloads, so /webhook should expect to receive POST requests and convert them to JSON objects. There are example webhook payloads in the museum/ directory of this repository. There are also examples of webhook payloads in the Github documentation. Installing Uncle Archie Webhooks in a Github Repo \u00b6 To install Uncle Archie in a Github repo you must be an admin or owner of that repo. Go to the repository's Settings page and pick Webhooks on the left side. Click the Add Webhook button. This will ask you for the webhook format, the webhook URL endpoint, the webhook secret, and which events you want to send. The webhook format should be JSON - that's the drop-down menu. The webhook URL endpoint is, as mentioned above, the URL of the Uncle Archie server plus /webhook . The webhook secret is set in config.json , loaded by the Flask application. This is used to verify that incoming webhooks are, in fact, legitimate. Finally, the events that you want to send should be picked out from the menu of possible webhook events, affording the CI server maximum flexibility.","title":"Flask"},{"location":"flask/#flask-webhook-server","text":"The front end component of Uncle Archie is the flask webhook server. This is a server with one endpoint. It receives webhooks and passes them on to Python hook functions on the back end.","title":"Flask Webhook Server"},{"location":"flask/#port-and-bind-address","text":"The Flask server listens on port 5005. Uncle Archie binds to 127.0.0.1:5005 on the host it runs on. (Note: this is important for the Nginx setup.)","title":"Port and Bind Address"},{"location":"flask/#routes","text":"Send all webhooks to Uncle Archie's /webhook endpoint. If your Uncle Archie server is running at archie.mydomain.com , then the URL for your webhook (the one you will install into Github repositories) will be https://archie.mydomain.com/webhook . (Also see the Nginx page.) Github webhooks are just JSON payloads, so /webhook should expect to receive POST requests and convert them to JSON objects. There are example webhook payloads in the museum/ directory of this repository. There are also examples of webhook payloads in the Github documentation.","title":"Routes"},{"location":"flask/#installing-uncle-archie-webhooks-in-a-github-repo","text":"To install Uncle Archie in a Github repo you must be an admin or owner of that repo. Go to the repository's Settings page and pick Webhooks on the left side. Click the Add Webhook button. This will ask you for the webhook format, the webhook URL endpoint, the webhook secret, and which events you want to send. The webhook format should be JSON - that's the drop-down menu. The webhook URL endpoint is, as mentioned above, the URL of the Uncle Archie server plus /webhook . The webhook secret is set in config.json , loaded by the Flask application. This is used to verify that incoming webhooks are, in fact, legitimate. Finally, the events that you want to send should be picked out from the menu of possible webhook events, affording the CI server maximum flexibility.","title":"Installing Uncle Archie Webhooks in a Github Repo"},{"location":"github/","text":"Adding Hooks in Github \u00b6 Once you have written a new Uncle Archie hook, it is being called from process_payload.py , and the Uncle Archie flask server has been restarted, you must activate webhooks in the repository. Installing Uncle Archie Webhooks in a Github Repo \u00b6 See Flask (section, \"Installing Uncle Archie Webhooks in a Github Repo\"). Dealing With SSH, Github Credentials, Private Repos \u00b6 Before testing whether Uncle Archie can access private repositories, make sure Uncle Archie is using the credentials that you expect. See the Startup Service page for more info on how to set up an isolated user account for Uncle Archie that has its own SSH keys and Github user credentials. Once the user account has been created, the Uncle Archie startup service can be modified to run as the dedicated user. Last, if you clone private repositories, you must use a URL scheme like git@github.com:owner/repo instead of https://github.com/owner/repo .","title":"Adding Hooks in Github"},{"location":"github/#adding-hooks-in-github","text":"Once you have written a new Uncle Archie hook, it is being called from process_payload.py , and the Uncle Archie flask server has been restarted, you must activate webhooks in the repository.","title":"Adding Hooks in Github"},{"location":"github/#installing-uncle-archie-webhooks-in-a-github-repo","text":"See Flask (section, \"Installing Uncle Archie Webhooks in a Github Repo\").","title":"Installing Uncle Archie Webhooks in a Github Repo"},{"location":"github/#dealing-with-ssh-github-credentials-private-repos","text":"Before testing whether Uncle Archie can access private repositories, make sure Uncle Archie is using the credentials that you expect. See the Startup Service page for more info on how to set up an isolated user account for Uncle Archie that has its own SSH keys and Github user credentials. Once the user account has been created, the Uncle Archie startup service can be modified to run as the dedicated user. Last, if you clone private repositories, you must use a URL scheme like git@github.com:owner/repo instead of https://github.com/owner/repo .","title":"Dealing With SSH, Github Credentials, Private Repos"},{"location":"hooks/","text":"Hooks \u00b6 What Are Hooks \u00b6 Each incoming webhook payload is passed to a set of hook functions, which are Python functions that live in the hooks/ folder. These are imported and called by process_python.py . How Are Hook Functions Defined? \u00b6 A hook is a Python file living in the hooks/ directory. it should define one method process_payload() with the same signature as the process_payload() method in process_payload.py . The new hook function should also be imported in the file process_payload.py - this contains a series of calls to hook functions, and this occurs for each webhook received. How To Define A New Hook Function? \u00b6 To make a new hook function: Add a python file to hooks/ Define a method process_payload() (following process_payload.py ) Import hook in process_payload.py And you're done defining your hook. How To Use A New Hook Function? \u00b6 Once you have defined a new hook function, and it is being called from process_payload.py , you must restart the Uncle Archie Flask server. To instruct Github to send webhooks for events in your repository to Uncle Archie, you must activate webhooks in the repositories where you want Uncle Archie to run. See Activating Hooks in Github .","title":"Hook Functions"},{"location":"hooks/#hooks","text":"","title":"Hooks"},{"location":"hooks/#what-are-hooks","text":"Each incoming webhook payload is passed to a set of hook functions, which are Python functions that live in the hooks/ folder. These are imported and called by process_python.py .","title":"What Are Hooks"},{"location":"hooks/#how-are-hook-functions-defined","text":"A hook is a Python file living in the hooks/ directory. it should define one method process_payload() with the same signature as the process_payload() method in process_payload.py . The new hook function should also be imported in the file process_payload.py - this contains a series of calls to hook functions, and this occurs for each webhook received.","title":"How Are Hook Functions Defined?"},{"location":"hooks/#how-to-define-a-new-hook-function","text":"To make a new hook function: Add a python file to hooks/ Define a method process_payload() (following process_payload.py ) Import hook in process_payload.py And you're done defining your hook.","title":"How To Define A New Hook Function?"},{"location":"hooks/#how-to-use-a-new-hook-function","text":"Once you have defined a new hook function, and it is being called from process_payload.py , you must restart the Uncle Archie Flask server. To instruct Github to send webhooks for events in your repository to Uncle Archie, you must activate webhooks in the repositories where you want Uncle Archie to run. See Activating Hooks in Github .","title":"How To Use A New Hook Function?"},{"location":"how/","text":"How It Works \u00b6 Uncle Archie is a home-brewed continuous integration (CI) server. Front End: Uncle Archie runs a frontend webhook server that receives webhooks from Github. This runs a Flask server using Jinja templates. This webhook server endpoint is installed into any Github repository that would potentially like to trigger CI builds with Uncle Archie. Back End: On the back end, the Flask server passes each webhook to a set of Python hook functions. Those functions then decide what to do with the payload. Example: An example of using Uncle Archie for CI testing is to run documentation tests with mkdocs on pull requests on a repository. To do this, we would define a hook function that takes a Github webhook payload (JSON/Python dictionary) as input, and looks for payloads that are updating or opening pull requests in specified repositories. It then clones a local copy of the head commit of that pull request, attempts to build mkdocs in the root of the repository, and marks the commit as \"success\" or \"failed\" depending on the outcome. The Uncle Archie repository contains a hook function in hooks/mkdocs_test.py that implements this test.","title":"How It Works"},{"location":"how/#how-it-works","text":"Uncle Archie is a home-brewed continuous integration (CI) server. Front End: Uncle Archie runs a frontend webhook server that receives webhooks from Github. This runs a Flask server using Jinja templates. This webhook server endpoint is installed into any Github repository that would potentially like to trigger CI builds with Uncle Archie. Back End: On the back end, the Flask server passes each webhook to a set of Python hook functions. Those functions then decide what to do with the payload. Example: An example of using Uncle Archie for CI testing is to run documentation tests with mkdocs on pull requests on a repository. To do this, we would define a hook function that takes a Github webhook payload (JSON/Python dictionary) as input, and looks for payloads that are updating or opening pull requests in specified repositories. It then clones a local copy of the head commit of that pull request, attempts to build mkdocs in the root of the repository, and marks the commit as \"success\" or \"failed\" depending on the outcome. The Uncle Archie repository contains a hook function in hooks/mkdocs_test.py that implements this test.","title":"How It Works"},{"location":"nginx/","text":"Nginx Web Server \u00b6 Background \u00b6 What Is Nginx? \u00b6 Nginx is a web server that can allow for a lot more flexibility in routing domain names and web traffic from the frontend to various backend servers. One of the more useful functionalities in nginx is the ability to set up a reverse proxy. What Is A Reverse Proxy? \u00b6 A proxy is defined as the authority to represent someone else . Typically a proxy is set up to \"surround\" and \"wrap\" actions that the user takes, and relay them to the \"outside world\" (i.e., the world beyond the proxy). A reverse proxy means that instead of \"surrounding\" and \"wrapping\" the client, a reverse proxy wraps the end server. That means that any requests for , say, https://archie.mydomain.com can be reverse proxied to the Uncle Archie Flask server at http://localhost:50005/ . The advantage of this is that Uncle Archie Flask is not accessible via port 50005 to outside users. Every request must pass through nginx. Installing Nginx \u00b6 Using your operating system's package manager is recommended: apt-get install nginx On Ubuntu, this will install configuration files to: /etc/nginx/ and will make nginx a service that can be started/stopped with: sudo service nginx start sudo service nginx stop Uncle Archie runs on port 50005 and is available at localhost:50005 . Nginx Standard Configuration \u00b6 The \"standard configuration\" for nginx is to use port 443 for HTTPS, port 80 for HTTP, and to automatically redirect HTTP requests on port 80 to the more secure port 443. The nginx configuration file below sets up nginx as a reverse proxy in front of Uncle Archie, and makes it available via a subdomain like archie.mysite.com . Here is the nginx configuration file and the location on disk where it should be using an aptitude-installed nginx (also see nginx/archie.conf in the repo): /etc/nginx/sites-available/archie.conf server { listen 80; listen [::]:80; server_name archie.nihdatacommons.us; location / { return 301 https://archie.nihdatacommons.us$request_uri; } } server { listen 443; listen [::]:443; server_name archie.nihdatacommons.us; ssl on; ssl_certificate /etc/letsencrypt/live/archie.nihdatacommons.us/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/archie.nihdatacommons.us/privkey.pem; include /etc/letsencrypt/options-ssl-nginx.conf; client_max_body_size 100m; gzip on; gzip_http_version 1.0; gzip_proxied any; gzip_min_length 500; gzip_disable \"MSIE [1-6]\\.\"; gzip_types text/plain text/xml text/css text/comma-separated-values text/javascript application/x-javascript application/atom+xml; ################# # This section is not necessary, # it makes the root url / into a # static hosted site root /www/archie.nihdatacommons.us/htdocs; location / { try_files $uri $uri/ =404; } # now on with the show... ################## location /webhook { # /webhook* anything takes user to port 5005, api proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://127.0.0.1:5005/webhook; } } The configuration file (full contents given above) should be copied to (requires sudo access): /etc/nginx/sites-available/archie.conf The site should then be enabled by linking this configuration file to the sites-enabled folder: sudo ln -fs /etc/nginx/sites-available/archie.conf /etc/nginx/sites-enabled/ Now nginx can be restarted: sudo service nginx restart","title":"Nginx"},{"location":"nginx/#nginx-web-server","text":"","title":"Nginx Web Server"},{"location":"nginx/#background","text":"","title":"Background"},{"location":"nginx/#what-is-nginx","text":"Nginx is a web server that can allow for a lot more flexibility in routing domain names and web traffic from the frontend to various backend servers. One of the more useful functionalities in nginx is the ability to set up a reverse proxy.","title":"What Is Nginx?"},{"location":"nginx/#what-is-a-reverse-proxy","text":"A proxy is defined as the authority to represent someone else . Typically a proxy is set up to \"surround\" and \"wrap\" actions that the user takes, and relay them to the \"outside world\" (i.e., the world beyond the proxy). A reverse proxy means that instead of \"surrounding\" and \"wrapping\" the client, a reverse proxy wraps the end server. That means that any requests for , say, https://archie.mydomain.com can be reverse proxied to the Uncle Archie Flask server at http://localhost:50005/ . The advantage of this is that Uncle Archie Flask is not accessible via port 50005 to outside users. Every request must pass through nginx.","title":"What Is A Reverse Proxy?"},{"location":"nginx/#installing-nginx","text":"Using your operating system's package manager is recommended: apt-get install nginx On Ubuntu, this will install configuration files to: /etc/nginx/ and will make nginx a service that can be started/stopped with: sudo service nginx start sudo service nginx stop Uncle Archie runs on port 50005 and is available at localhost:50005 .","title":"Installing Nginx"},{"location":"nginx/#nginx-standard-configuration","text":"The \"standard configuration\" for nginx is to use port 443 for HTTPS, port 80 for HTTP, and to automatically redirect HTTP requests on port 80 to the more secure port 443. The nginx configuration file below sets up nginx as a reverse proxy in front of Uncle Archie, and makes it available via a subdomain like archie.mysite.com . Here is the nginx configuration file and the location on disk where it should be using an aptitude-installed nginx (also see nginx/archie.conf in the repo): /etc/nginx/sites-available/archie.conf server { listen 80; listen [::]:80; server_name archie.nihdatacommons.us; location / { return 301 https://archie.nihdatacommons.us$request_uri; } } server { listen 443; listen [::]:443; server_name archie.nihdatacommons.us; ssl on; ssl_certificate /etc/letsencrypt/live/archie.nihdatacommons.us/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/archie.nihdatacommons.us/privkey.pem; include /etc/letsencrypt/options-ssl-nginx.conf; client_max_body_size 100m; gzip on; gzip_http_version 1.0; gzip_proxied any; gzip_min_length 500; gzip_disable \"MSIE [1-6]\\.\"; gzip_types text/plain text/xml text/css text/comma-separated-values text/javascript application/x-javascript application/atom+xml; ################# # This section is not necessary, # it makes the root url / into a # static hosted site root /www/archie.nihdatacommons.us/htdocs; location / { try_files $uri $uri/ =404; } # now on with the show... ################## location /webhook { # /webhook* anything takes user to port 5005, api proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass http://127.0.0.1:5005/webhook; } } The configuration file (full contents given above) should be copied to (requires sudo access): /etc/nginx/sites-available/archie.conf The site should then be enabled by linking this configuration file to the sites-enabled folder: sudo ln -fs /etc/nginx/sites-available/archie.conf /etc/nginx/sites-enabled/ Now nginx can be restarted: sudo service nginx restart","title":"Nginx Standard Configuration"},{"location":"payloads/","text":"How Payloads Are Processed \u00b6 Uncle Archie runs a Flask server to receive webhooks. Github sends webhooks in the form of JSON to the Flask server when events occur on Github. The JSON file contains lots of information about the event. The JSON webhook is converted to a Python dictionary and is passed to the process_payload() function defined in process_payload.py . Hooks \u00b6 Directory: hooks/ Each incoming webhook payload is passed to a set of hook functions, which are Python functions that live in the hooks/ folder. These are imported and called by process_python.py . See Hooks for details about how the hooks work and how to define new ones. Payload Museum \u00b6 To see examples of payloads, visit the Payload Museum in the museum/ directory of the repository. Uncle Archie Configuration File \u00b6 File: config.json The configuration file config.json contains both Flask and back end hook function configuration details. An example of a Flask configuration variable is the secret key that must be included with the webhook's header for the webhook to be processed. An example of a back end hook function's configuration detail is the Github API access token for the bot account that Uncle Archie uses, which is only used in the hook functions to interact with the Github API. (API keys are sensitive information so this file should be kept secret, hence the configuration file is in .gitignore ). The config is loaded by the Flask application, since it contains flask-specific configuration details. The configuration is then handed off to the process payload function, which passes it on to each hook function. It is available via the variable conf .","title":"Payload Processing"},{"location":"payloads/#how-payloads-are-processed","text":"Uncle Archie runs a Flask server to receive webhooks. Github sends webhooks in the form of JSON to the Flask server when events occur on Github. The JSON file contains lots of information about the event. The JSON webhook is converted to a Python dictionary and is passed to the process_payload() function defined in process_payload.py .","title":"How Payloads Are Processed"},{"location":"payloads/#hooks","text":"Directory: hooks/ Each incoming webhook payload is passed to a set of hook functions, which are Python functions that live in the hooks/ folder. These are imported and called by process_python.py . See Hooks for details about how the hooks work and how to define new ones.","title":"Hooks"},{"location":"payloads/#payload-museum","text":"To see examples of payloads, visit the Payload Museum in the museum/ directory of the repository.","title":"Payload Museum"},{"location":"payloads/#uncle-archie-configuration-file","text":"File: config.json The configuration file config.json contains both Flask and back end hook function configuration details. An example of a Flask configuration variable is the secret key that must be included with the webhook's header for the webhook to be processed. An example of a back end hook function's configuration detail is the Github API access token for the bot account that Uncle Archie uses, which is only used in the hook functions to interact with the Github API. (API keys are sensitive information so this file should be kept secret, hence the configuration file is in .gitignore ). The config is loaded by the Flask application, since it contains flask-specific configuration details. The configuration is then handed off to the process payload function, which passes it on to each hook function. It is available via the variable conf .","title":"Uncle Archie Configuration File"},{"location":"quick/","text":"Quick Start \u00b6 To get started, clone a local copy of the Uncle Archie repo: git clone git@github.com:charlesreid1/uncle-archie cd uncle-archie Next, run the Uncle Archie Flask server in a virtual environment: virtualenv vp source vp/bin/activate vp/bin/pip install -r requirements.txt vp/bin/python uncle_archie.py This will start the Uncle Archie Flask server at http://localhost:5005 . We use Uncle Archie behind an Nginx reverse proxy (see the Nginx page), which enables accessing Uncle Archie via an HTTPS address at a trusted domain name like https://archie.mydomain.com . Defining Your First Hook Function: \u00b6 Uncle Archie receives incoming webhooks from Github, and passes each webhook to a set of Python hook functions. There are several hook functions included with Uncle Archie, see the hooks/ directory. To write your first hook function, create a new file in hooks/ that defines a function process_payload(payload, meta, config) , where all arguments are dictionaries. def process_payload(payload, meta, config): # Do some stuff here pass Put this in a Python file in the hooks/ directory: cat > hooks/my_cool_hook.py <<EOF def process_payload(payload, meta, config): # Do some stuff here, # like use the payload to see # if this is an event we are # interested in, or create a # Github API instance. pass EOF Now edit process_payload.py in the repo so that it loads this new hook: # ... # other import statements # ... from hooks.my_cool_hook import process_payload as my_cool_hook def process_payload(payload,meta,config): # ... # other function calls # ... my_cool_hook(payload,meta,config) Uncle Archie will now call the new hook every time an incoming webhook is received by the Flask server. Sending Github Webhooks to Uncle Archie: \u00b6 Github will only send webhooks to Uncle Archie if webhooks are set up in a Github repository. To have Uncle Archie run CI tests in a given repo, like coolkid/mycoolrepo , visit the repository in Github and go to the repository Settings. Select Webhooks from the menu. Select Add Webhook. For the URL endpoint, enter the address at which Github can reach your webhook server. This is where having a proper Nginx setup with SSL becomes important. For the secret, enter the same secret that is in the Flask configuration file config_flask.py . For the type of events to deliver, you should select the types of events you want your hook function to react to. In the next section we'll make a hook function that reacts to pull request events, so try selecting the two \"Pull Request\" options. Save the webhook. Github will test your webhook server by sending a \"ping\" message; it expects \"pong\" back. If your server is reachable and responds with pong, the webhook will have a green check, otherwise a red x. A More Interesting Pull Request Hook Function \u00b6 The hook function above is really boring, so let's replace it with a slightly more interesting one. This one inspects the payload to look for pull request events that open new pull requests or modify existing pull requests: cat > hooks/my_cool_hook.py <<EOF def process_payload(payload, meta, config): if 'pull_request' not in payload.keys(): # This is not a pull request return if 'action' not in payload.keys(): # This is not a pull request action return if payload['action'] not in ['opened','synchronize']: # This pull request event is not interesting - # neither opening a new PR, # nor modifying an existing PR return # Get the repository name full_repo_name = payload['repository']['full_name'] # Implement some sort of whitelist # of repositories that you expect # incoming webhooks from. # Get the head commit head_commit = payload['pull_request']['head']['sha'] # This message isn't going to go anywhere useful, # so write files on disk if you need to store/export data print(\"The current commiti is %s\"%(head_commit)) pass EOF You can find other hook functions in the hooks/ directory of the repository.","title":"Quick Start"},{"location":"quick/#quick-start","text":"To get started, clone a local copy of the Uncle Archie repo: git clone git@github.com:charlesreid1/uncle-archie cd uncle-archie Next, run the Uncle Archie Flask server in a virtual environment: virtualenv vp source vp/bin/activate vp/bin/pip install -r requirements.txt vp/bin/python uncle_archie.py This will start the Uncle Archie Flask server at http://localhost:5005 . We use Uncle Archie behind an Nginx reverse proxy (see the Nginx page), which enables accessing Uncle Archie via an HTTPS address at a trusted domain name like https://archie.mydomain.com .","title":"Quick Start"},{"location":"quick/#defining-your-first-hook-function","text":"Uncle Archie receives incoming webhooks from Github, and passes each webhook to a set of Python hook functions. There are several hook functions included with Uncle Archie, see the hooks/ directory. To write your first hook function, create a new file in hooks/ that defines a function process_payload(payload, meta, config) , where all arguments are dictionaries. def process_payload(payload, meta, config): # Do some stuff here pass Put this in a Python file in the hooks/ directory: cat > hooks/my_cool_hook.py <<EOF def process_payload(payload, meta, config): # Do some stuff here, # like use the payload to see # if this is an event we are # interested in, or create a # Github API instance. pass EOF Now edit process_payload.py in the repo so that it loads this new hook: # ... # other import statements # ... from hooks.my_cool_hook import process_payload as my_cool_hook def process_payload(payload,meta,config): # ... # other function calls # ... my_cool_hook(payload,meta,config) Uncle Archie will now call the new hook every time an incoming webhook is received by the Flask server.","title":"Defining Your First Hook Function:"},{"location":"quick/#sending-github-webhooks-to-uncle-archie","text":"Github will only send webhooks to Uncle Archie if webhooks are set up in a Github repository. To have Uncle Archie run CI tests in a given repo, like coolkid/mycoolrepo , visit the repository in Github and go to the repository Settings. Select Webhooks from the menu. Select Add Webhook. For the URL endpoint, enter the address at which Github can reach your webhook server. This is where having a proper Nginx setup with SSL becomes important. For the secret, enter the same secret that is in the Flask configuration file config_flask.py . For the type of events to deliver, you should select the types of events you want your hook function to react to. In the next section we'll make a hook function that reacts to pull request events, so try selecting the two \"Pull Request\" options. Save the webhook. Github will test your webhook server by sending a \"ping\" message; it expects \"pong\" back. If your server is reachable and responds with pong, the webhook will have a green check, otherwise a red x.","title":"Sending Github Webhooks to Uncle Archie:"},{"location":"quick/#a-more-interesting-pull-request-hook-function","text":"The hook function above is really boring, so let's replace it with a slightly more interesting one. This one inspects the payload to look for pull request events that open new pull requests or modify existing pull requests: cat > hooks/my_cool_hook.py <<EOF def process_payload(payload, meta, config): if 'pull_request' not in payload.keys(): # This is not a pull request return if 'action' not in payload.keys(): # This is not a pull request action return if payload['action'] not in ['opened','synchronize']: # This pull request event is not interesting - # neither opening a new PR, # nor modifying an existing PR return # Get the repository name full_repo_name = payload['repository']['full_name'] # Implement some sort of whitelist # of repositories that you expect # incoming webhooks from. # Get the head commit head_commit = payload['pull_request']['head']['sha'] # This message isn't going to go anywhere useful, # so write files on disk if you need to store/export data print(\"The current commiti is %s\"%(head_commit)) pass EOF You can find other hook functions in the hooks/ directory of the repository.","title":"A More Interesting Pull Request Hook Function"},{"location":"service/","text":"Startup Service \u00b6 File: scripts/archie.service Quick Version \u00b6 Start by creating a separate user account on your *nix box that will be used to run Uncle Archie with separate SSH and Github user credentials than your regular account. Create a new user: adduser florence Log in as the new user and (i) generate a new SSH key, and (ii) add lines to your ~/.bash_profile that will set your Github username/email credentials. sudo -H -u florence /bin/bash # now you are the user florence # generate ssh key ssh-keygen -t rsa -N '' -b 4096 -f $HOME/.ssh/id_rsa -C \"<email-of-github-bot-account>\" chmod 700 $HOME/.ssh touch $HOME/.ssh/authorized_keys chmod 600 $HOME/.ssh/authorized_keys # add this to ~/bash_profile GIT_AUTHOR_NAME=\"<uncle-archie-bot-name>\" GIT_AUTHOR_EMAIL=\"<uncle-archie-bot-email>\" GIT_COMMITTER_NAME=\"${GIT_AUTHOR_NAME}\" GIT_COMMITTER_EMAIL=\"$GIT_AUTHOR_EMAIL\" git config --global user.name \"${GIT_AUTHOR_NAME}\" git config --global user.email \"${GIT_AUTHOR_EMAIL}\" Update archie.service to run Uncle Archie as the new user you just created, by setting the username in the two lines ExecStart=/user/bin/sudo -H -u <username> ... ExecStop=/user/bin/sudo -H -u <username> ... Install the startup service by copying to /etc/systemd/system/archie.servce . Then activate it: sudo cp scripts/archie.service /etc/systemd/system/archie.service sudo systemctl enable archie.service Now you can start/stop the service with: sudo systemctl (start|stop) archie.service Start/Stop Archie Scripts \u00b6 You may be wondering why we require a script to start and stop Uncle Archie. There are several challenges running Uncle Archie as a startup service, and multiple setup steps involved. These include: Startup services run as the root user, but we want Uncle Archie to run as a normal user We want to use a virtual python environment with packages installed from requirements.txt, not the system python or a user python that may have outdated or missing packages. We need the SSH and Github user credentials that Uncle Archie will use to match those of the Github bot account we're using to run Uncle Archie, and not the personal credentials of the developer whose machine Uncle Archie is running on. That's what the start_archie.sh script does.","title":"Startup Service"},{"location":"service/#startup-service","text":"File: scripts/archie.service","title":"Startup Service"},{"location":"service/#quick-version","text":"Start by creating a separate user account on your *nix box that will be used to run Uncle Archie with separate SSH and Github user credentials than your regular account. Create a new user: adduser florence Log in as the new user and (i) generate a new SSH key, and (ii) add lines to your ~/.bash_profile that will set your Github username/email credentials. sudo -H -u florence /bin/bash # now you are the user florence # generate ssh key ssh-keygen -t rsa -N '' -b 4096 -f $HOME/.ssh/id_rsa -C \"<email-of-github-bot-account>\" chmod 700 $HOME/.ssh touch $HOME/.ssh/authorized_keys chmod 600 $HOME/.ssh/authorized_keys # add this to ~/bash_profile GIT_AUTHOR_NAME=\"<uncle-archie-bot-name>\" GIT_AUTHOR_EMAIL=\"<uncle-archie-bot-email>\" GIT_COMMITTER_NAME=\"${GIT_AUTHOR_NAME}\" GIT_COMMITTER_EMAIL=\"$GIT_AUTHOR_EMAIL\" git config --global user.name \"${GIT_AUTHOR_NAME}\" git config --global user.email \"${GIT_AUTHOR_EMAIL}\" Update archie.service to run Uncle Archie as the new user you just created, by setting the username in the two lines ExecStart=/user/bin/sudo -H -u <username> ... ExecStop=/user/bin/sudo -H -u <username> ... Install the startup service by copying to /etc/systemd/system/archie.servce . Then activate it: sudo cp scripts/archie.service /etc/systemd/system/archie.service sudo systemctl enable archie.service Now you can start/stop the service with: sudo systemctl (start|stop) archie.service","title":"Quick Version"},{"location":"service/#startstop-archie-scripts","text":"You may be wondering why we require a script to start and stop Uncle Archie. There are several challenges running Uncle Archie as a startup service, and multiple setup steps involved. These include: Startup services run as the root user, but we want Uncle Archie to run as a normal user We want to use a virtual python environment with packages installed from requirements.txt, not the system python or a user python that may have outdated or missing packages. We need the SSH and Github user credentials that Uncle Archie will use to match those of the Github bot account we're using to run Uncle Archie, and not the personal credentials of the developer whose machine Uncle Archie is running on. That's what the start_archie.sh script does.","title":"Start/Stop Archie Scripts"}]}